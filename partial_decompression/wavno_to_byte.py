"""
This script creates an indexed mapping of wave numbers to byte offsets
using the offsets generated by the `indexed_file.py` script.

It reads a bzip2-compressed file, extracts wave numbers, and maps them
to their corresponding byte offsets. The result is saved as a JSON file,
allowing users to query a wave number and retrieve the corresponding
byte offset in the file.
"""


import os
import re
import json
import pickle
from indexed_bzip2 import ibz2

# parameters
INPUT_BZ2    = "02_HITEMP2024.par.bz2"
OFFSETS_FILE = "CO2_indexed_offsets.dat"
OUTPUT_JSON  = "wav_to_byte_index.json"
STEP_MB      = 500        # every 500 MB
MAX_MB       = 54000      # ~54 GB decompressed file

# regex to capture the first float after the integer index
wav_no_re = re.compile(r"^\s*\d+\s+([+-]?\d*\.\d+)")

# load block offsets
with open(OFFSETS_FILE, 'rb') as f:
    block_offsets = pickle.load(f)

# open compressed file and set offsets
f = ibz2.open(INPUT_BZ2, parallelization=os.cpu_count())
f.set_block_offsets(block_offsets)

wav_index = {}

# for each 500 MB step
for mb in range(0, MAX_MB + 1, STEP_MB):
    byte_off = mb * 1024 * 1024
    f.seek(byte_off)
    f.readline()  # drop remainder of current line
    line = f.readline().decode('utf-8', errors='replace').strip()
    if not line:
        continue

    # 4. extract wav_no via regex
    m = wav_no_re.match(line)
    if m:
        wav_no = m.group(1)
        wav_index[wav_no] = byte_off
    else:
        # fallback: log or inspect lines that didn't match
        print(f"WARNING: couldn't parse wav_no in line at {byte_off}:\n  {line}")

f.close()

# Dump to JSON
with open(OUTPUT_JSON, 'w') as jf:
    json.dump(wav_index, jf, indent=2)

print(f"Indexed {len(wav_index)} entries → {OUTPUT_JSON}")
